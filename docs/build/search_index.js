var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api.html#Main-Types","page":"API Reference","title":"Main Types","text":"","category":"section"},{"location":"api.html#System","page":"API Reference","title":"System","text":"","category":"section"},{"location":"api.html#Magesty.System","page":"API Reference","title":"Magesty.System","text":"System\n\nA collection of structure, symmetry, cluster, and basis set.\n\nFields\n\nconfig::Parser: Configuration parser\nstructure::Structure: Crystal structure information\nsymmetry::Symmetry: Symmetry operations\ncluster::Cluster: Cluster information\nbasisset::BasisSet: Basis set information\n\n\n\n\n\n","category":"type"},{"location":"api.html#SpinCluster","page":"API Reference","title":"SpinCluster","text":"","category":"section"},{"location":"api.html#Magesty.SpinCluster","page":"API Reference","title":"Magesty.SpinCluster","text":"SpinCluster\n\nAn extension of System with optimization capabilities.\n\nFields\n\nconfig::Parser: Configuration parser\nstructure::Structure: Crystal structure information\nsymmetry::Symmetry: Symmetry operations\ncluster::Cluster: Cluster information\nbasisset::BasisSet: Basis set information\noptimize::Optimizer: Optimizer instance\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api.html#System-Creation","page":"API Reference","title":"System Creation","text":"","category":"section"},{"location":"api.html#Magesty.System-Tuple{Dict{<:AbstractString}}","page":"API Reference","title":"Magesty.System","text":"System\n\nCreate a System instance from either a dictionary of input parameters or a TOML configuration file.\n\nArguments\n\ninput_dict::Dict{<:AbstractString, <:Any}: Dictionary containing input parameters.\ntoml_file::AbstractString: Path to the TOML configuration file.\nverbosity::Bool=true: Whether to print detailed information during initialization.\n\nReturns\n\nSystem: A new System instance containing structure, symmetry, cluster, and basis set.\n\nThrows\n\nSystemError: If the TOML file cannot be read.\nErrorException: If required parameters are missing, invalid, or the TOML parsing fails.\n\nExamples\n\n# Create a System from a dictionary\ninput_dict = Dict(\"key\" => \"value\")\nsystem = System(input_dict)\n\n# Create a System from a TOML file\nsystem = System(\"config.toml\")\n\n\n\n\n\n","category":"method"},{"location":"api.html#SpinCluster-Creation","page":"API Reference","title":"SpinCluster Creation","text":"","category":"section"},{"location":"api.html#Magesty.SpinCluster-Tuple{Dict{<:AbstractString}}","page":"API Reference","title":"Magesty.SpinCluster","text":"SpinCluster\n\nCreate a SpinCluster instance from either a dictionary of input parameters, a TOML configuration file, or an existing System instance. This is an extension of System that includes optimization capabilities.\n\nArguments\n\ninput_dict::Dict{<:AbstractString, <:Any}: Dictionary containing input parameters.\ntoml_file::AbstractString: Path to the TOML configuration file.\nsystem::System: An existing System instance.\nverbosity::Bool=true: Whether to print detailed information during initialization.\n\nReturns\n\nSpinCluster: A new SpinCluster instance containing structure, symmetry, cluster, basis set, and optimizer.\n\nThrows\n\nSystemError: If the TOML file cannot be read.\nErrorException: If required parameters are missing, invalid, or the TOML parsing fails.\n\nExamples\n\n# Create a SpinCluster from a dictionary\ninput_dict = Dict(\"key\" => \"value\")\nspin_cluster = SpinCluster(input_dict)\n\n# Create a SpinCluster from a TOML file\nspin_cluster = SpinCluster(\"config.toml\")\n\n# Create a SpinCluster from an existing System\nsystem = System(\"config.toml\")\nspin_cluster = SpinCluster(system)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Magesty.SpinCluster-Tuple{System, Dict{<:AbstractString}}","page":"API Reference","title":"Magesty.SpinCluster","text":"SpinCluster(system::System, input_dict::Dict{<:AbstractString, <:Any}; verbosity::Bool = true)\n\nCreates a SpinCluster instance by extending an existing System object with optimization capabilities.  This constructor uses a dictionary of input parameters to configure the optimization process.\n\nArguments\n\nsystem::System: An existing System instance containing structure, symmetry, cluster, and basis set information.\ninput_dict::Dict{<:AbstractString, <:Any}: A dictionary containing input parameters for optimization.\nverbosity::Bool=true: Whether to print detailed information during initialization.\n\nReturns\n\nSpinCluster: A new SpinCluster instance containing structure, symmetry, cluster, basis set, and optimizer.\n\nThrows\n\nErrorException: If required parameters are missing or invalid.\n\nExample\n\ninput_dict = Dict(\"key\" => \"value\")\nsystem = System(input_dict)\nspin_cluster = SpinCluster(system, input_dict)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Magesty.SpinCluster-Tuple{System, AbstractDict{<:AbstractString}, AbstractVector{Magesty.SpinConfigs.SpinConfig}}","page":"API Reference","title":"Magesty.SpinCluster","text":"SpinCluster\n\nCreate a SpinCluster instance from a System and a list of SpinConfig objects. This constructor is used when the optimization process is based on predefined spin configurations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Energy-and-Torque-Calculations","page":"API Reference","title":"Energy and Torque Calculations","text":"","category":"section"},{"location":"api.html#Magesty.calc_energy","page":"API Reference","title":"Magesty.calc_energy","text":"calc_energy(sc::SpinCluster, spin_config::AbstractMatrix{<:Real})\n\nCalculate the energy of a spin configuration using the spin cluster expansion.\n\nArguments\n\nsc::SpinCluster: A SpinCluster instance containing structure, symmetry, basis set, and optimization information.\nspin_config::AbstractMatrix{<:Real}: A 3xN matrix representing the spin configuration, where N is the number of atoms in the supercell.\n\nReturns\n\nFloat64: The calculated energy of the given spin configuration.\n\nThrows\n\nArgumentError: If the number of columns in spin_config does not match the number of atoms in the supercell.\n\nExample\n\nspin_config = rand(3, sc.structure.supercell.num_atoms) # Random spin configuration\nenergy = calc_energy(sc, spin_config)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Results-Access","page":"API Reference","title":"Results Access","text":"","category":"section"},{"location":"api.html#Magesty.get_j0","page":"API Reference","title":"Magesty.get_j0","text":"get the reference energy\n\n\n\n\n\n","category":"function"},{"location":"api.html#Magesty.get_jphi","page":"API Reference","title":"Magesty.get_jphi","text":"get the spin-cluster coefficients\n\n\n\n\n\n","category":"function"},{"location":"api.html#Magesty.get_j0_jphi","page":"API Reference","title":"Magesty.get_j0_jphi","text":"get the reference energy and spin-cluster coefficients\n\n\n\n\n\n","category":"function"},{"location":"api.html#Output-Functions","page":"API Reference","title":"Output Functions","text":"","category":"section"},{"location":"api.html#Magesty.write_xml","page":"API Reference","title":"Magesty.write_xml","text":"write_xml(structure::Structure, basis_set::BasisSet, optimize::Optimizer, filename::AbstractString=\"jphi.xml\"; write_jphi::Bool=true)\nwrite_xml(sc::SpinCluster, filename::AbstractString=\"jphi.xml\"; write_jphi::Bool=true)\n\nWrite the structure, basis set, and optimization results to an XML file in SCE format.\n\nArguments\n\nstructure::Structure: Crystal structure information\nbasis_set::BasisSet: Basis set information\noptimize::Optimizer: Optimization results\nsc::SpinCluster: Spin cluster object containing structure, basis set, and optimization results\nfilename::AbstractString=\"jphi.xml\": Output XML file name\nwrite_jphi::Bool=true: Whether to write the J_ij parameters\n\nExamples\n\n# Using individual components\nwrite_xml(structure, basis_set, optimizer)\nwrite_xml(structure, basis_set, optimizer, \"output.xml\", write_jphi=false)\n\n# Using SpinCluster object\nwrite_xml(spin_cluster)\nwrite_xml(spin_cluster, \"output.xml\", write_jphi=false)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Submodules","page":"API Reference","title":"Submodules","text":"","category":"section"},{"location":"api.html#Structures","page":"API Reference","title":"Structures","text":"","category":"section"},{"location":"api.html#Magesty.Structures.Structure","page":"API Reference","title":"Magesty.Structures.Structure","text":"Structure\n\nRepresents a periodic structure built from a Cell, with information about periodicity, atom types, and neighboring images.\n\nFields\n\nsupercell::Cell   The unit cell of the structure, containing lattice vectors, reciprocal vectors, atomic positions, and magnetic moments.\nis_periodic::Vector{Bool}   A vector indicating periodicity along each of the three principal axes. Each element corresponds to whether the structure is periodic (true) or non-periodic (false) along that axis.\nkd_name::Vector{String}   A list of element names present in the structure without deplication (e.g., [\"Fe\", \"Co\", \"Ni\"]).\nx_image_frac::Array{Float64, 3}   Fractional coordinates of atoms in neighboring (imaginary) cells. The dimensions typically represent the number of images, number of atoms, and the three fractional coordinates.\nx_image_cart::Array{Float64, 3}   Cartesian coordinates of atoms in neighboring (imaginary) cells. Similar to x_image_frac, the dimensions represent the number of images, number of atoms, and the three Cartesian coordinates.\nexist_image::Vector{Bool}   Indicates the existence of neighboring cells based on the structure's periodicity. Each element corresponds to whether a particular neighboring cell exists (true) or not (false).\natomtype_group::Vector{Vector{Int}}   Groups of atom indices categorized by their types. Each sub-vector contains the indices of atoms belonging to a specific element type.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Symmetries","page":"API Reference","title":"Symmetries","text":"","category":"section"},{"location":"api.html#Magesty.Symmetries.Symmetry","page":"API Reference","title":"Magesty.Symmetries.Symmetry","text":"struct Symmetry\n\nContains the symmetry information of a structure.\n\nFields\n\ninternational_symbol::String: International symbol of the space group.\nspacegroup_number::Int: Space group number.\nnsym::Int: Number of symmetry operations.\nntran::Int: Number of pure translation operations.\nnat_prim::Int: Number of atoms in the primitive cell.\ntol::Float64: Tolerance for symmetry detection.\natoms_in_prim::Vector{Int}: Indices of atoms in the primitive cell.\nsymdata::Vector{SymmetryOperation}: List of symmetry operations.\nmap_sym::Matrix{Int}: Maps atoms in the supercell to corresponding atoms under symmetry operations.\nmap_p2s::Matrix{Int}: Maps atoms in the primitive cell to the supercell.\nmap_s2p::Vector{Maps}: Maps atoms in the supercell to the primitive cell.\nsymnum_translation::Vector{Int}: Indices of pure translation operations.\n\nConstructor\n\nSymmetry(structure, tol::Float64)\n\nGenerate symmetry information for the given structure using the specified tolerance.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.Symmetries.SymmetryOperation","page":"API Reference","title":"Magesty.Symmetries.SymmetryOperation","text":"struct SymmetryOperation\n\nRepresents a symmetry operation, including rotation and translation components.\n\nFields\n\nrotation_frac::SMatrix{3, 3, Float64, 9}: The 3x3 rotation matrix in fractional coordinates.\nrotation_cart::SMatrix{3, 3, Float64, 9}: The 3x3 rotation matrix in Cartesian coordinates.\ntranslation_frac::SVector{3, Float64}: The 3x1 translation vector in fractional coordinates.\nis_translation::Bool: True if the operation is a pure translation.\nis_translation_included::Bool: True if the operation includes a translation.\nis_proper::Bool: True if the rotation is proper (determinant > 0).\n\nExamples\n\n# Create a symmetry operation\nsymop = SymmetryOperation(\n\trotation_frac = [1 0 0; 0 1 0; 0 0 1],\n\trotation_cart = [1 0 0; 0 1 0; 0 0 1],\n\ttranslation_frac = [0.0, 0.0, 0.0],\n\tis_translation = true,\n\tis_translation_included = false,\n\tis_proper = true\n)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.Symmetries.Maps","page":"API Reference","title":"Magesty.Symmetries.Maps","text":"Maps Maps structure is used in Symmetry structure to map supercell atom to primitive index.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Clusters","page":"API Reference","title":"Clusters","text":"","category":"section"},{"location":"api.html#Magesty.Clusters.Cluster","page":"API Reference","title":"Magesty.Clusters.Cluster","text":"struct Cluster\n\nRepresents a collection of interaction clusters based on the specified number of bodies and cutoff radii.\n\nFields\n\nnum_bodies::Int: Number of interacting bodies\ncutoff_radii::Array{Float64, 3}: Cutoff radii for each atomic element pair and interaction body\nmin_distance_pairs::Matrix{Vector{DistInfo}}: Matrix of minimum distance pairs between atoms\ninteraction_clusters::Matrix{OrderedSet{InteractionCluster}}: Matrix of interaction clusters\ncluster_list::Vector{SortedVector{Vector{AtomCell}}}: List of interacting atom clusters\nequivalent_atom_list::Vector{Vector{Int}}: List of equivalent atom groups\n\nConstructor\n\nCluster(structure, symmetry, nbody, cutoff_radii)\n\nCreates a new Cluster instance based on the provided structure, symmetry information, number of bodies, and cutoff radii.\n\nExample\n\n```julia cluster = Cluster(structure, symmetry, 3, cutoff_radii)\n\n\n\n\n\n","category":"type"},{"location":"api.html#BasisSets","page":"API Reference","title":"BasisSets","text":"","category":"section"},{"location":"api.html#Magesty.BasisSets.BasisSet","page":"API Reference","title":"Magesty.BasisSets.BasisSet","text":"struct BasisSet\n\nRepresents a set of basis functions for atomic interactions in a crystal structure. This structure is used to store and manage basis functions that are adapted to the symmetry of the crystal.\n\nFields\n\nbasislist::SortedCountingUniqueVector{IndicesUniqueList}: List of unique basis indices with their counts\nclassified_basisdict::Dict{Int, SortedCountingUniqueVector}: Dictionary mapping symmetry labels to basis sets\nprojection_dict::Dict{Int, Matrix{Float64}}: Dictionary of projection matrices for each symmetry label\neach_projection_dict::Any: Dictionary containing individual projection information\nsalc_list::Vector{SALC}: List of symmetry-adapted linear combinations\n\nConstructors\n\nBasisSet(structure::Structure, symmetry::Symmetry, cluster::Cluster, lmax::AbstractMatrix{<:Integer}, bodymax::Integer)\n\nConstructs a new BasisSet instance for atomic interactions in a crystal structure.\n\nArguments\n\nstructure::Structure: Structure information containing atomic positions and species\nsymmetry::Symmetry: Symmetry information for the crystal structure\ncluster::Cluster: Cluster information for atomic interactions\nlmax::AbstractMatrix{<:Integer}: Matrix of maximum angular momentum values for each atomic species and body [nkd × nbody]\nbodymax::Integer: Maximum number of bodies in interactions\n\nReturns\n\nBasisSet: A new basis set instance containing:\nList of unique basis functions\nSymmetry-classified basis dictionary\nProjection matrices\nSymmetry-adapted linear combinations\n\nExamples\n\n# Create a basis set for a structure with 2 atomic species and 3-body interactions\nlmax_matrix = [2 3; 3 2]  # lmax for each species and body\nbasis = BasisSet(structure, symmetry, cluster, lmax_matrix, 3)\n\nNote\n\nThe constructor performs the following steps:\n\nConstructs the basis list by considering all possible combinations of atoms and angular momenta\nClassifies basis functions by symmetry operations\nConstructs projection matrices for each symmetry label\nGenerates symmetry-adapted linear combinations (SALCs)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Optimization","page":"API Reference","title":"Optimization","text":"","category":"section"},{"location":"api.html#Spin-Configurations","page":"API Reference","title":"Spin Configurations","text":"","category":"section"},{"location":"api.html#Magesty.SpinConfigs.SpinConfig","page":"API Reference","title":"Magesty.SpinConfigs.SpinConfig","text":"SpinConfig\n\nA configuration of spins in a magnetic structure.\n\nFields\n\nenergy::Float64: The energy of the spin configuration [eV]\nmagmom_size::Vector{Float64}: The magnitude of magnetic moments for each atom [μ_B]\nspin_directions::Matrix{Float64}: The direction cosines (unit vectors) of the spins [3 × num_atoms]\nlocal_magfield::Matrix{Float64}: The local magnetic field at each atom [T]\nlocal_magfield_vertical::Matrix{Float64}: The component of the local magnetic field perpendicular to the magnetic moments [T]\n\nConstructors\n\nSpinConfig(energy, magmom_size, spin_directions, local_magfield): Create a spin configuration\n\nThrows\n\nArgumentError if dimensions of input arrays do not match\nArgumentError if any magnetic moment size is negative\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.SpinConfigs.read_embset","page":"API Reference","title":"Magesty.SpinConfigs.read_embset","text":"read_embset(filepath::AbstractString, num_atoms::Integer) -> Vector{SpinConfig}\n\nRead spin configurations from an EMBSET file.\n\nArguments\n\nfilepath::AbstractString: Path to the EMBSET file\nnum_atoms::Integer: Number of atoms in the structure\n\nReturns\n\nVector{SpinConfig}: Array of spin configurations\n\nThrows\n\nErrorException if the file format is invalid\nArgumentError if the file does not exist\n\n\n\n\n\n","category":"function"},{"location":"api.html#Utility-Types","page":"API Reference","title":"Utility Types","text":"","category":"section"},{"location":"api.html#Atomic-Indices","page":"API Reference","title":"Atomic Indices","text":"","category":"section"},{"location":"api.html#Magesty.AtomicIndices.Indices","page":"API Reference","title":"Magesty.AtomicIndices.Indices","text":"Indices(atom::Int, l::Int, m::Int, cell::Int)\n\nRepresents the indices of an atom along with its associated quantum numbers (l and m) and cell index in a real spherical harmonics basis.\n\nFields\n\natom::Int: The index of the atom.\nl::Int: The quantum number (l).\nm::Int: The quantum number (m).\ncell::Int: The cell index (1 ≤ cell ≤ 27).\n\nConstructor\n\nIndices(atom::Int, l::Int, m::Int, cell::Int): Creates a new Indices instance after validating:\nl must be positive\n|m| must not exceed l\ncell must be between 1 and 27 (inclusive)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.AtomicIndices.IndicesUniqueList","page":"API Reference","title":"Magesty.AtomicIndices.IndicesUniqueList","text":"IndicesUniqueList\n\nA mutable collection of unique Indices objects that implements the AbstractVector interface. Maintains uniqueness of elements and provides specialized operations for handling atomic indices.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.AtomicIndices.get_total_L","page":"API Reference","title":"Magesty.AtomicIndices.get_total_L","text":"get_total_L(iul::IndicesUniqueList) -> Int\n\nReturn the sum of all l values in IndicesUniqueList.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SALCs-(Symmetry-Adapted-Linear-Combinations)","page":"API Reference","title":"SALCs (Symmetry-Adapted Linear Combinations)","text":"","category":"section"},{"location":"api.html#Magesty.SALCs.SALC","page":"API Reference","title":"Magesty.SALCs.SALC","text":"SALC\n\nA structure representing a symmetry-adapted linear combination.\n\nFields\n\nbasisset::Vector{IndicesUniqueList}: The basis set of atomic indices\ncoeffs::Vector{Float64}: The coefficients of the linear combination\nmultiplicity::Vector{Int}: The multiplicity of each basis element\n\nConstructors\n\nSALC(basisset::Vector{IndicesUniqueList}, coeffs::Vector{Float64}, multiplicity::Vector{Int}): Create a SALC from a basis set, coefficients, and multiplicity\n\n\n\n\n\n","category":"type"},{"location":"api.html#Unitary-Matrix","page":"API Reference","title":"Unitary Matrix","text":"","category":"section"},{"location":"api.html#Magesty.UnitaryMatrixCl.UniMatCl","page":"API Reference","title":"Magesty.UnitaryMatrixCl.UniMatCl","text":"UniMatCl{T <: Complex} <: AbstractMatrix{T}\n\nA structure storing unitary matrix Cˡ, where Cˡ is defined as \tSₗ = CˡYₗ where Sₗ and Yₗ are vectors consisting of real and complex spherical harmonics, respectively. The dimension of Cˡ is (2l+1) × (2l+1).\n\nFields\n\numat_cl::Matrix{T}: The unitary matrix Cˡ\nl::Int: The angular momentum quantum number\n\nConstructors\n\nUniMatCl(l::Integer): Create a unitary matrix Cˡ for a given l\nUniMatCl(mat::AbstractMatrix{<:Complex}): Create a unitary matrix Cˡ from an existing matrix\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.UnitaryMatrixCl.getindex_m","page":"API Reference","title":"Magesty.UnitaryMatrixCl.getindex_m","text":"getindex_m(cl::UniMatCl, m1::Integer, m2::Integer) -> Complex\n\nGet the matrix element Cˡ(m1, m2) using quantum numbers m1 and m2.\n\nArguments\n\ncl::UniMatCl: The unitary matrix\nm1::Integer: The first quantum number\nm2::Integer: The second quantum number\n\nReturns\n\nComplex: The matrix element Cˡ(m1, m2)\n\nThrows\n\nBoundsError if m1 or m2 is outside the valid range [-l, l]\n\n\n\n\n\n","category":"function"},{"location":"api.html#Atom-Cells","page":"API Reference","title":"Atom Cells","text":"","category":"section"},{"location":"api.html#Magesty.AtomCells.AtomCell","page":"API Reference","title":"Magesty.AtomCells.AtomCell","text":"AtomCell(atom::Int, cell::Int)\n\nA structure that stores atom index and imaginary (virtual) cell index.\n\nFields\n\natom::Int: Index of the atom\ncell::Int: Index of the imaginary cell\n\nExamples\n\njulia> ac = AtomCell(1, 2)\n(atom: 1, cell: 2)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Configuration-Parsers","page":"API Reference","title":"Configuration Parsers","text":"","category":"section"},{"location":"api.html#Magesty.ConfigParser.Config4System","page":"API Reference","title":"Magesty.ConfigParser.Config4System","text":"Config4System\n\nA structure that holds system configuration parameters for molecular dynamics simulations.\n\nRequired Parameters\n\nname::String: Name of the system\nnum_atoms::Int: Number of atoms in the system\nkd_name::Vector{String}: List of chemical species names\nnbody::Int: Maximum order of many-body interactions\nlmax::Matrix{Int}: Maximum angular momentum for each chemical species and interaction order\ncutoff_radii::Array{Float64, 3}: Cutoff radii for interactions between chemical species\nlattice_vectors::Matrix{Float64}: Lattice vectors of the system\nkd_int_list::Vector{Int}: List of chemical species indices for each atom\nx_fractional::Matrix{Float64}: Fractional coordinates of atoms\n\nOptional Parameters\n\nis_periodic::Vector{Bool}: Periodicity flags for each direction [default: [true, true, true]]\ntolerance_sym::Float64: Tolerance for symmetry operations [default: 1e-3]\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.ConfigParser.Config4Optimize","page":"API Reference","title":"Magesty.ConfigParser.Config4Optimize","text":"Config4Optimize\n\nA structure that holds optimization parameters.\n\nRequired Parameters\n\ndatafile::String: Path to the data file\n\nOptional Parameters\n\nndata::Int: Number of data points to use [default: -1]\nweight::Float64: Weight for optimization [default: 0.0]\n\n\n\n\n\n","category":"type"},{"location":"api.html#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api.html#Spherical-Harmonics","page":"API Reference","title":"Spherical Harmonics","text":"","category":"section"},{"location":"api.html#Magesty.MySphericalHarmonics.Sₗₘ","page":"API Reference","title":"Magesty.MySphericalHarmonics.Sₗₘ","text":"Sₗₘ(l::Integer, m::Integer, uvec::AbstractVector{<:Real}) -> Float64\n\nCompute the real spherical harmonic Sₗₘ.\n\nArguments\n\nl: Angular momentum quantum number (≥ 0)\nm: Magnetic quantum number (-l ≤ m ≤ l)\nuvec: Normalized 3D direction vector [r̂x, r̂y, r̂z]\n\nMathematical Details\n\nFor m = 0:  Sₗₘ = P̄ₗₘ(r̂z) For m > 0:  Sₗₘ = (-1)ᵐ√2 P̄ₗₘ(r̂z) ∑ₖ (-1)ᵏ (m,2k) r̂x^(m-2k) r̂y^(2k) For m < 0:  Sₗₘ = (-1)ⁿ√2 P̄ₗₘ(r̂z) ∑ₖ (-1)ᵏ (n,2k+1) r̂x^(n-2k-1) r̂y^(2k+1)\n\nwhere n = |m| and (n,k) denotes binomial coefficient.\n\nReference: Equation (***) in T. Tanaka and Y. Gohda, ***\n\n\n\n\n\n","category":"function"},{"location":"api.html#Rotation-Matrices","page":"API Reference","title":"Rotation Matrices","text":"","category":"section"},{"location":"api.html#Magesty.RotationMatrix.rotmat2euler","page":"API Reference","title":"Magesty.RotationMatrix.rotmat2euler","text":"rotmat2euler(m::AbstractMatrix{<:Real}, mod_positive::Bool = true) -> Tuple{Float64, Float64, Float64}\n\nConverts a 3x3 rotation matrix m to Euler angles (α, β, γ).\n\nArguments\n\nm::AbstractMatrix{<:Real}: A 3x3 rotation matrix.\nmod_positive::Bool: If true, the angles are adjusted to be within [0, 2π) for α and γ. Defaults to true.\n\nReturns\n\nTuple{Float64, Float64, Float64}: The Euler angles (α, β, γ).\n\nRaises\n\nArgumentError: If the input matrix m is not 3x3.\n\nExamples\n\n```julia m = [1 0 0; 0 cos(pi/4) -sin(pi/4); 0 sin(pi/4) cos(pi/4)] angles = rotmat2euler(m) println(angles)  # (0.0, 0.7853981633974483, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"api.html#Magesty.RotationMatrix.Δl","page":"API Reference","title":"Magesty.RotationMatrix.Δl","text":"Δl(l::Int, α::Float64, β::Float64, γ::Float64)::Matrix{Float64}\n\nCompute the Δ matrix for a given l, α, β, and γ.\n\nArguments\n\nl::Int: Positive integer representing the angular momentum quantum number.\nα::Float64, β::Float64, γ::Float64: Euler angles in radians.\n\nReturns\n\nA real-valued matrix Δ::Matrix{Float64}.\n\nThrows\n\nArgumentError if l is not positive.\nArgumentError if the resulting matrix contains imaginary parts exceeding the threshold 1e-12.\n\nNotes\n\nThe resulting matrix is converted to real if the imaginary parts are negligible.\n\nReferences\n\nM.A. Blanco et al., Journal of Molecular Structure (Theochem) 419 19-27 (1997).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Energy-Calculations","page":"API Reference","title":"Energy Calculations","text":"","category":"section"},{"location":"api.html#Version-Information","page":"API Reference","title":"Version Information","text":"","category":"section"},{"location":"api.html#Magesty.Version.version_string","page":"API Reference","title":"Magesty.Version.version_string","text":"version_string()\n\nReturns the version information as a string.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Container-Types","page":"API Reference","title":"Container Types","text":"","category":"section"},{"location":"api.html#Sorted-Containers","page":"API Reference","title":"Sorted Containers","text":"","category":"section"},{"location":"api.html#Magesty.SortedContainer.SortedVector","page":"API Reference","title":"Magesty.SortedContainer.SortedVector","text":"SortedVector{T} <: AbstractSortedVector{T}\n\nA mutable sorted vector of elements of type T.   This structure maintains its internal data::Vector{T} in sorted order.\n\nFields\n\ndata::Vector{T}: The underlying sorted array storing all elements.\n\nConstructors\n\nSortedVector(data): Create a SortedVector by sorting and storing a copy of data.\nSortedVector{T}(): Create an empty SortedVector{T}.\nSortedVector(): Create an empty SortedVector{Any}.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.SortedContainer.SortedUniqueVector","page":"API Reference","title":"Magesty.SortedContainer.SortedUniqueVector","text":"SortedUniqueVector{T} <: AbstractSortedVector{T}\n\nA mutable sorted vector that maintains unique elements of type T.\n\nFields\n\ndata::Vector{T}: The underlying array, always sorted and without duplicates.\n\nConstructors\n\nSortedUniqueVector(data): Create a SortedUniqueVector by sorting, removing duplicates, and storing a copy of data.\nSortedUniqueVector{T}(): Create an empty SortedUniqueVector{T}.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Magesty.SortedContainer.SortedCountingUniqueVector","page":"API Reference","title":"Magesty.SortedContainer.SortedCountingUniqueVector","text":"SortedCountingUniqueVector{T} <: AbstractSortedVector{T}\n\nA mutable sorted vector of unique elements (like SortedUniqueVector) that also tracks how many times each element was inserted.\n\nFields\n\ndata::SortedUniqueVector{T}: The underlying sorted collection of unique elements.\ncounts::Dict{T,Int}: A dictionary mapping each element to its insertion count.\n\nConstructors\n\nSortedCountingUniqueVector{T}(): Create an empty counting vector.\nSortedCountingUniqueVector(data::AbstractVector{T}): Create a counting vector from data, counting each element's occurrences.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Counting-Containers","page":"API Reference","title":"Counting Containers","text":"","category":"section"},{"location":"api.html#Constants","page":"API Reference","title":"Constants","text":"","category":"section"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This page provides comprehensive examples of using Magesty.jl for various magnetic structure analysis tasks.","category":"page"},{"location":"examples.html#Example-1:-Simple-BCC-Iron","page":"Examples","title":"Example 1: Simple BCC Iron","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates the basic workflow for a simple BCC iron structure.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\n\n# Define input parameters\ninput_dict = Dict(\n    \"structure\" => Dict(\n        \"lattice\" => [[2.87, 0.0, 0.0], [0.0, 2.87, 0.0], [0.0, 0.0, 2.87]],\n        \"atoms\" => [[\"Fe\", [0.0, 0.0, 0.0]]]\n    ),\n    \"optimization\" => Dict(\n        \"method\" => \"LBFGS\",\n        \"max_iterations\" => 1000,\n        \"tolerance\" => 1e-6\n    )\n)\n\n# Create system and spin cluster\nsystem = System(input_dict)\nsc = SpinCluster(system, input_dict)\n\n# Generate random spin configuration\nnum_atoms = sc.structure.supercell.num_atoms\nspin_config = rand(3, num_atoms)\nfor i in 1:num_atoms\n    spin_config[:, i] ./= norm(spin_config[:, i])\nend\n\n# Calculate energy\nenergy = calc_energy(sc, spin_config)\nprintln(\"Energy: \", energy)\n\n# Export results\nwrite_xml(sc, \"bcc_fe_results.xml\")","category":"page"},{"location":"examples.html#Example-2:-Ferromagnetic-vs-Antiferromagnetic","page":"Examples","title":"Example 2: Ferromagnetic vs Antiferromagnetic","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example compares ferromagnetic and antiferromagnetic configurations.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\n\n# Load configuration\nsc = SpinCluster(\"config.toml\")\nnum_atoms = sc.structure.supercell.num_atoms\n\n# Ferromagnetic configuration (all spins aligned)\nfm_config = ones(3, num_atoms)\nfor i in 1:num_atoms\n    fm_config[:, i] ./= norm(fm_config[:, i])\nend\n\n# Antiferromagnetic configuration (alternating spins)\nafm_config = zeros(3, num_atoms)\nfor i in 1:num_atoms\n    if i % 2 == 1\n        afm_config[1, i] = 1.0  # +x direction\n    else\n        afm_config[1, i] = -1.0  # -x direction\n    end\nend\n\n# Calculate energies\nfm_energy = calc_energy(sc, fm_config)\nafm_energy = calc_energy(sc, afm_config)\n\nprintln(\"Ferromagnetic energy: \", fm_energy)\nprintln(\"Antiferromagnetic energy: \", afm_energy)\nprintln(\"Energy difference: \", afm_energy - fm_energy)","category":"page"},{"location":"examples.html#Example-3:-Spin-Wave-Analysis","page":"Examples","title":"Example 3: Spin Wave Analysis","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates how to analyze spin wave excitations.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\nusing LinearAlgebra\n\n# Create spin cluster\nsc = SpinCluster(\"config.toml\")\nnum_atoms = sc.structure.supercell.num_atoms\n\n# Create ground state configuration\nground_state = zeros(3, num_atoms)\nground_state[1, :] .= 1.0  # All spins along x-axis\n\n# Calculate ground state energy\nground_energy = calc_energy(sc, ground_state)\n\n# Create small perturbation\nperturbation = 0.1 * randn(3, num_atoms)\nexcited_state = ground_state + perturbation\n\n# Normalize spins\nfor i in 1:num_atoms\n    excited_state[:, i] ./= norm(excited_state[:, i])\nend\n\n# Calculate excited state energy\nexcited_energy = calc_energy(sc, excited_state)\n\n# Calculate excitation energy\nexcitation_energy = excited_energy - ground_energy\nprintln(\"Excitation energy: \", excitation_energy)","category":"page"},{"location":"examples.html#Example-4:-Symmetry-Analysis","page":"Examples","title":"Example 4: Symmetry Analysis","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates how to analyze the symmetry properties of a magnetic structure.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\n\n# Create system\nsystem = System(\"config.toml\")\n\n# Access symmetry information\nsymmetry = system.symmetry\nprintln(\"Number of symmetry operations: \", length(symmetry.symmetry_operations))\n\n# Print symmetry operations\nfor (i, symop) in enumerate(symmetry.symmetry_operations)\n    println(\"Symmetry operation $i:\")\n    println(\"  Rotation (fractional): \", symop.rotation_frac)\n    println(\"  Translation (fractional): \", symop.translation_frac)\n    println(\"  Is proper: \", symop.is_proper)\n    println()\nend\n\n# Access structure information\nstructure = system.structure\nprintln(\"Lattice vectors:\")\nfor i in 1:3\n    println(\"  a$i: \", structure.supercell.lattice_vectors[i, :])\nend\n\nprintln(\"Atomic positions (fractional):\")\nfor i in 1:structure.supercell.num_atoms\n    element = structure.kd_name[structure.supercell.kd_int_list[i]]\n    pos = structure.supercell.x_frac[:, i]\n    println(\"  $element: \", pos)\nend","category":"page"},{"location":"examples.html#Example-5:-Cluster-Analysis","page":"Examples","title":"Example 5: Cluster Analysis","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates how to analyze the cluster expansion.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\n\n# Create spin cluster\nsc = SpinCluster(\"config.toml\")\n\n# Access cluster information\ncluster = sc.cluster\nprintln(\"Number of interaction clusters: \", length(cluster.interaction_clusters))\n\n# Print cluster information\nfor (i, interaction_cluster) in enumerate(cluster.interaction_clusters)\n    println(\"Cluster $i:\")\n    println(\"  Number of atoms: \", length(interaction_cluster.atom_indices))\n    println(\"  Atom indices: \", interaction_cluster.atom_indices)\n    println(\"  Maximum distance: \", interaction_cluster.distmax)\n    println()\nend\n\n# Access basis set information\nbasisset = sc.basisset\nprintln(\"Number of basis functions: \", length(basisset.salc_list))\n\n# Print basis function information\nfor (i, salc) in enumerate(basisset.salc_list)\n    println(\"Basis function $i:\")\n    println(\"  Cluster index: \", salc.cluster_index)\n    println(\"  Angular momentum: \", salc.l)\n    println(\"  Magnetic quantum number: \", salc.m)\n    println()\nend","category":"page"},{"location":"examples.html#Example-6:-Optimization-Results","page":"Examples","title":"Example 6: Optimization Results","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates how to access and analyze optimization results.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\n\n# Create spin cluster with optimization\nsc = SpinCluster(\"config.toml\")\n\n# Get optimization results\nj0 = get_j0(sc)\njphi = get_jphi(sc)\n\nprintln(\"Reference energy (J0): \", j0)\nprintln(\"Number of spin-cluster coefficients: \", length(jphi))\nprintln(\"First 10 coefficients: \", jphi[1:min(10, length(jphi))])\n\n# Analyze coefficient magnitudes\nmax_coeff = maximum(abs.(jphi))\nmin_coeff = minimum(abs.(jphi))\nprintln(\"Maximum coefficient magnitude: \", max_coeff)\nprintln(\"Minimum coefficient magnitude: \", min_coeff)\n\n# Find most important coefficients\nimportant_indices = findall(x -> abs(x) > 0.1 * max_coeff, jphi)\nprintln(\"Important coefficient indices: \", important_indices)","category":"page"},{"location":"examples.html#Example-7:-Custom-Spin-Configurations","page":"Examples","title":"Example 7: Custom Spin Configurations","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates how to work with custom spin configurations.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\nusing LinearAlgebra\n\n# Create spin cluster\nsc = SpinCluster(\"config.toml\")\nnum_atoms = sc.structure.supercell.num_atoms\n\n# Create custom spin configuration\nspin_config = zeros(3, num_atoms)\n\n# Set spins in a specific pattern\nfor i in 1:num_atoms\n    # Create a spiral pattern\n    angle = 2π * i / num_atoms\n    spin_config[1, i] = cos(angle)\n    spin_config[2, i] = sin(angle)\n    spin_config[3, i] = 0.0\nend\n\n# Calculate energy and torque\nenergy = calc_energy(sc, spin_config)\ntorque = calc_torque(sc, spin_config)\n\nprintln(\"Spiral configuration energy: \", energy)\nprintln(\"Maximum torque magnitude: \", maximum(norm.(eachcol(torque))))\n\n# Create another configuration (random)\nrandom_config = randn(3, num_atoms)\nfor i in 1:num_atoms\n    random_config[:, i] ./= norm(random_config[:, i])\nend\n\nrandom_energy = calc_energy(sc, random_config)\nprintln(\"Random configuration energy: \", random_energy)","category":"page"},{"location":"examples.html#Example-8:-Batch-Processing","page":"Examples","title":"Example 8: Batch Processing","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates how to process multiple configurations efficiently.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Magesty\n\n# Create spin cluster\nsc = SpinCluster(\"config.toml\")\nnum_atoms = sc.structure.supercell.num_atoms\n\n# Generate multiple random configurations\nn_configs = 100\nenergies = Float64[]\nconfigurations = []\n\nfor i in 1:n_configs\n    # Generate random configuration\n    config = randn(3, num_atoms)\n    for j in 1:num_atoms\n        config[:, j] ./= norm(config[:, j])\n    end\n    \n    # Calculate energy\n    energy = calc_energy(sc, config)\n    \n    push!(energies, energy)\n    push!(configurations, config)\nend\n\n# Analyze results\nprintln(\"Number of configurations: \", length(energies))\nprintln(\"Minimum energy: \", minimum(energies))\nprintln(\"Maximum energy: \", maximum(energies))\nprintln(\"Average energy: \", mean(energies))\nprintln(\"Standard deviation: \", std(energies))\n\n# Find lowest energy configuration\nmin_index = argmin(energies)\nprintln(\"Lowest energy configuration index: \", min_index)\nprintln(\"Lowest energy: \", energies[min_index])","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"These examples demonstrate the versatility and power of Magesty.jl for magnetic structure analysis and spin cluster expansion calculations. Each example can be adapted and extended for specific research needs.","category":"page"},{"location":"index.html#Magesty.jl","page":"Home","title":"Magesty.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Magesty.jl is a Julia package for magnetic structure analysis and spin cluster expansion calculations. It provides comprehensive tools for:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Magnetic structure setup and management\nSymmetry analysis and operations\nCluster expansion calculations\nBasis function generation\nSpin configuration optimization","category":"page"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Magesty\")","category":"page"},{"location":"index.html#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Magesty\n\n# Load configuration from a TOML file\nsc = SpinCluster(\"config.toml\")\n\n# Calculate energy for a spin configuration\nspin_config = rand(3, sc.structure.supercell.num_atoms)\nenergy = calc_energy(sc, spin_config)\n\n# Get optimization results\nj0 = get_j0(sc)  # Reference energy\njphi = get_jphi(sc)  # Spin-cluster coefficients","category":"page"},{"location":"index.html#Creating-a-System","page":"Home","title":"Creating a System","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"# From a TOML configuration file\nsystem = System(\"input.toml\")\n\n# From a dictionary\ninput_dict = Dict(\n    \"structure\" => Dict(\n        \"lattice\" => [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]],\n        \"atoms\" => [[\"Fe\", [0.0, 0.0, 0.0]]]\n    )\n)\nsystem = System(input_dict)","category":"page"},{"location":"index.html#Main-Components","page":"Home","title":"Main Components","text":"","category":"section"},{"location":"index.html#System","page":"Home","title":"System","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A collection of structure, symmetry, cluster, and basis set information.","category":"page"},{"location":"index.html#SpinCluster","page":"Home","title":"SpinCluster","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"An extension of System with optimization capabilities for spin configurations.","category":"page"},{"location":"index.html#Submodules","page":"Home","title":"Submodules","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Structures: Crystal structure processing\nSymmetries: Symmetry operations processing  \nClusters: Cluster expansion processing\nBasisSets: Basis function generation\nOptimize: Spin configuration optimization","category":"page"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Magnetic Structure Analysis: Process and analyze magnetic crystal structures\nSymmetry Operations: Apply and analyze symmetry operations on magnetic structures\nCluster Expansion: Perform spin cluster expansion calculations\nBasis Functions: Generate symmetry-adapted basis functions\nOptimization: Optimize spin configurations using various algorithms\nXML Output: Export results in SCE (Spin Cluster Expansion) format","category":"page"},{"location":"index.html#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"See the API Reference for detailed documentation of all functions and types.","category":"page"},{"location":"index.html#Tools","page":"Home","title":"Tools","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Magesty.jl includes a comprehensive set of utility tools in the tools/ directory for:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Data Processing: Convert between different file formats (VASP, TOML, XML)\nAnalysis: Compare energies, perform cross-validation, analyze magnetic moments\nVisualization: Create plots for Bader analysis, charge density, and magnetic structures\nSampling: Generate spin configurations using various statistical methods\nAdvanced Analysis: Calculate micromagnetics parameters and spin wave dispersion","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See the Tools page for detailed documentation of all available tools.","category":"page"},{"location":"tools.html#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"This page describes the various utility tools available in the tools/ directory of Magesty.jl. These tools provide additional functionality for data processing, analysis, and visualization.","category":"page"},{"location":"tools.html#Data-Processing-Tools","page":"Tools","title":"Data Processing Tools","text":"","category":"section"},{"location":"tools.html#pos2toml.jl","page":"Tools","title":"pos2toml.jl","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Convert VASP structure files (POSCAR) to TOML configuration files for Magesty.jl.","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Usage:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"julia pos2toml.jl --input POSCAR --output structure.toml","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Features:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Parses VASP POSCAR format\nConverts to Magesty.jl TOML format\nHandles both direct and Cartesian coordinates\nSupports scaling factors and element symbols","category":"page"},{"location":"tools.html#extract.jl","page":"Tools","title":"extract.jl","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Extract data from various file formats used in magnetic calculations.","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Usage:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"julia extract.jl --input data_file --format vasp","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Supported formats:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"VASP output files\nEMBSET files\nXML configuration files","category":"page"},{"location":"tools.html#Visualization-Tools","page":"Tools","title":"Visualization Tools","text":"","category":"section"},{"location":"tools.html#histogram_magmom.jl","page":"Tools","title":"histogram_magmom.jl","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Generate histograms of magnetic moments.","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Usage:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"julia histogram_magmom.jl --input magmom_data.dat --output histogram.png","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Features:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Creates histograms of magnetic moment distributions\nSupports multiple data formats\nCustomizable bin sizes and ranges","category":"page"},{"location":"tools.html#yyplot.jl","page":"Tools","title":"yyplot.jl","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Create YY plots for magnetic structure analysis.","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Usage:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"julia yyplot.jl --input data.toml --output yy_plot.png","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Features:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Generates YY plots for magnetic structures\nSupports multiple data formats\nCustomizable plot parameters","category":"page"},{"location":"tools.html#Sampling-and-Statistical-Tools","page":"Tools","title":"Sampling and Statistical Tools","text":"","category":"section"},{"location":"tools.html#sampling_mfa.jl","page":"Tools","title":"sampling_mfa.jl","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Sample spin configurations using Mean-Field Approximation (MFA).","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Usage:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"julia sampling_mfa.jl input.toml tau --start 0.1 --end 2.0 --step 0.1 --num_samples 100","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Features:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Samples spin configurations at specified temperatures\nUses von Mises-Fisher distribution\nSupports temperature range sampling\nConfigurable number of samples","category":"page"},{"location":"tools.html#Advanced-Analysis-Tools","page":"Tools","title":"Advanced Analysis Tools","text":"","category":"section"},{"location":"tools.html#micromagnetics.jl","page":"Tools","title":"micromagnetics.jl","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Calculate micromagnetics model parameters.","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Usage:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"julia micromagnetics.jl --input jphi.xml --output micromagnetics.dat","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Features:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Derives micromagnetics model parameters\nCalculates stiffness and spiralization matrices\nSupports multi-threading","category":"page"},{"location":"tools.html#convert2tensor.jl","page":"Tools","title":"convert2tensor.jl","text":"","category":"section"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Convert between different tensor representations.","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Usage:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"using convert2tensor\ntensor = convert_to_tensor(data, format=\"matrix\")","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Features:","category":"page"},{"location":"tools.html","page":"Tools","title":"Tools","text":"Converts between tensor formats\nSupports various input/output formats\nHandles symmetry operations","category":"page"},{"location":"tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"This tutorial will guide you through the basic usage of Magesty.jl for magnetic structure analysis and spin cluster expansion calculations.","category":"page"},{"location":"tutorial.html#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"First, install Magesty.jl:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"Magesty\")","category":"page"},{"location":"tutorial.html#Basic-Workflow","page":"Tutorial","title":"Basic Workflow","text":"","category":"section"},{"location":"tutorial.html#1.-Setting-up-a-Configuration","page":"Tutorial","title":"1. Setting up a Configuration","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Magesty.jl uses TOML configuration files to specify input parameters. Here's a basic example:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"[structure]\nlattice = [[2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 2.0]]\natoms = [[\"Fe\", [0.0, 0.0, 0.0]], [\"Fe\", [0.5, 0.5, 0.5]]]\n\n[optimization]\nmethod = \"LBFGS\"\nmax_iterations = 1000\ntolerance = 1e-6","category":"page"},{"location":"tutorial.html#2.-Creating-a-System","page":"Tutorial","title":"2. Creating a System","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using Magesty\n\n# Create a system from a TOML file\nsystem = System(\"config.toml\")\n\n# Or create from a dictionary\ninput_dict = Dict(\n    \"structure\" => Dict(\n        \"lattice\" => [[2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 2.0]],\n        \"atoms\" => [[\"Fe\", [0.0, 0.0, 0.0]], [\"Fe\", [0.5, 0.5, 0.5]]]\n    )\n)\nsystem = System(input_dict)","category":"page"},{"location":"tutorial.html#3.-Creating-a-SpinCluster-for-Optimization","page":"Tutorial","title":"3. Creating a SpinCluster for Optimization","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Create a SpinCluster for optimization\nsc = SpinCluster(\"config.toml\")\n\n# Or create from an existing System\nsc = SpinCluster(system, input_dict)","category":"page"},{"location":"tutorial.html#4.-Calculating-Energies","page":"Tutorial","title":"4. Calculating Energies","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Generate a random spin configuration\nnum_atoms = sc.structure.supercell.num_atoms\nspin_config = rand(3, num_atoms)\n\n# Normalize spins to unit length\nfor i in 1:num_atoms\n    spin_config[:, i] ./= norm(spin_config[:, i])\nend\n\n# Calculate energy\nenergy = calc_energy(sc, spin_config)\nprintln(\"Energy: \", energy)","category":"page"},{"location":"tutorial.html#5.-Accessing-Results","page":"Tutorial","title":"5. Accessing Results","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Get reference energy\nj0 = get_j0(sc)\n\n# Get spin-cluster coefficients\njphi = get_jphi(sc)\n\n# Get both\nj0, jphi = get_j0_jphi(sc)","category":"page"},{"location":"tutorial.html#6.-Exporting-Results","page":"Tutorial","title":"6. Exporting Results","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Write results to XML file\nwrite_xml(sc, \"results.xml\")\n\n# Write without J_ij parameters\nwrite_xml(sc, \"structure_only.xml\", write_jphi=false)","category":"page"},{"location":"tutorial.html#Advanced-Usage","page":"Tutorial","title":"Advanced Usage","text":"","category":"section"},{"location":"tutorial.html#Working-with-Spin-Configurations","page":"Tutorial","title":"Working with Spin Configurations","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Create specific spin configurations\nspin_config = zeros(3, num_atoms)\nspin_config[1, :] .= 1.0  # All spins along x-axis\n\n# Calculate energy and torque\nenergy = calc_energy(sc, spin_config)\ntorque = calc_torque(sc, spin_config)","category":"page"},{"location":"tutorial.html#Symmetry-Analysis","page":"Tutorial","title":"Symmetry Analysis","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Access symmetry information\nsymmetry = sc.symmetry\nprintln(\"Number of symmetry operations: \", length(symmetry.symmetry_operations))\n\n# Access structure information\nstructure = sc.structure\nprintln(\"Number of atoms: \", structure.supercell.num_atoms)\nprintln(\"Lattice vectors: \", structure.supercell.lattice_vectors)","category":"page"},{"location":"tutorial.html#Cluster-Information","page":"Tutorial","title":"Cluster Information","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Access cluster information\ncluster = sc.cluster\nprintln(\"Number of clusters: \", length(cluster.interaction_clusters))\n\n# Access basis set information\nbasisset = sc.basisset\nprintln(\"Number of basis functions: \", length(basisset.salc_list))","category":"page"},{"location":"tutorial.html#Configuration-Options","page":"Tutorial","title":"Configuration Options","text":"","category":"section"},{"location":"tutorial.html#Structure-Parameters","page":"Tutorial","title":"Structure Parameters","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"lattice: 3x3 matrix of lattice vectors\natoms: List of [element, position] pairs\nsupercell: Supercell dimensions (optional)","category":"page"},{"location":"tutorial.html#Optimization-Parameters","page":"Tutorial","title":"Optimization Parameters","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"method: Optimization method (\"LBFGS\", \"CG\", etc.)\nmax_iterations: Maximum number of iterations\ntolerance: Convergence tolerance\nalpha: Regularization parameter\nlambda: Weight parameter","category":"page"},{"location":"tutorial.html#Symmetry-Parameters","page":"Tutorial","title":"Symmetry Parameters","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"tolerance: Symmetry detection tolerance\nuse_spglib: Whether to use Spglib for symmetry detection","category":"page"},{"location":"tutorial.html#Troubleshooting","page":"Tutorial","title":"Troubleshooting","text":"","category":"section"},{"location":"tutorial.html#Common-Issues","page":"Tutorial","title":"Common Issues","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"File not found: Make sure the TOML file path is correct\nInvalid configuration: Check that all required parameters are present\nMemory issues: For large systems, consider reducing the cluster cutoff radius\nConvergence problems: Try adjusting the tolerance or maximum iterations","category":"page"},{"location":"tutorial.html#Getting-Help","page":"Tutorial","title":"Getting Help","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Check the API Reference for detailed function documentation\nLook at the Examples for more complex use cases\nReport issues on the GitHub repository","category":"page"}]
}
